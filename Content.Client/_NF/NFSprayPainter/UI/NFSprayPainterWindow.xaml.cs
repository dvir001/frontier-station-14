using System.Linq;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client._NF.NFSprayPainter.UI;

[GenerateTypedNameReferences]
public sealed partial class NFSprayPainterWindow : DefaultWindow
{
    [Dependency] private readonly IEntitySystemManager _sysMan = default!;
    private readonly SpriteSystem _spriteSystem;

    public Action<string, int>? OnSpritePicked;

    private ItemList ColorList = default!;
    public Action<ItemList.ItemListSelectedEventArgs>? OnColorPicked;
    public Dictionary<string, int> ItemColorIndex = new();

    private Dictionary<string, Color> _currentPalette = new();
    private const string ColorLocKeyPrefix = "pipe-painter-color-";
    private Dictionary<string, List<NFSprayPainterEntry>> _currentEntries = new();

    private readonly SpriteSpecifier _colorEntryIconTexture = new SpriteSpecifier.Rsi(
        new ResPath("Structures/Piping/Atmospherics/pipe.rsi"),
        "pipeStraight");

    public NFSprayPainterWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _spriteSystem = _sysMan.GetEntitySystem<SpriteSystem>();
    }

    private static string GetColorLocString(string? colorKey)
    {
        if (string.IsNullOrEmpty(colorKey))
            return Loc.GetString("pipe-painter-no-color-selected");
        var locKey = ColorLocKeyPrefix + colorKey;

        if (!Loc.TryGetString(locKey, out var locString))
            locString = colorKey;

        return locString;
    }

    public string? IndexToColorKey(int index)
    {
        return (string?) ColorList[index].Metadata;
    }

    private void OnItemSelected(BaseButton.ButtonEventArgs args, ListData data)
    {
        if (data is SpriteListData listData && args.Button is ListContainerButton button)
            OnSpritePicked?.Invoke(listData.Category, button.Index);
    }

    public void Populate(Dictionary<string, List<NFSprayPainterEntry>> entries, Dictionary<string, int> selectedStyles, string? selectedColorKey, Dictionary<string, Color> palette)
    {
        // Only clear if the entries change. Otherwise the list would "jump" after selecting an item
        if (!_currentEntries.Equals(entries))
        {
            _currentEntries = entries;

            foreach (var category in entries.Keys)
            {
                var box = new BoxContainer() { Orientation = BoxContainer.LayoutOrientation.Vertical };
                var label = new Label() { Text = Loc.GetString("spray-painter-selected-style") };

                var spriteList = new ListContainer()
                {
                    Toggle = true,
                    Group = true,
                    GenerateItem = GenerateItems,
                };
                var dataList = entries[category].Select(e => new SpriteListData(category, e.Name, e.Proto, selectedStyles[category])).ToList();
                spriteList.PopulateList(dataList);
                spriteList.ItemPressed += OnItemSelected;

                box.AddChild(label);
                box.AddChild(spriteList);
                Tabs.AddChild(box);

                var tabLocalization = Loc.GetString("spray-painter-tabs-" + category);
                TabContainer.SetTabTitle(box, tabLocalization);
            }
        }

        if (!_currentPalette.Equals(palette))
        {
            _currentPalette = palette;
            ItemColorIndex.Clear();

            ColorList = new ItemList() { VerticalExpand = true };
            var label = new Label() { Text = Loc.GetString("spray-painter-selected-color") };
            var box = new BoxContainer() { Orientation = BoxContainer.LayoutOrientation.Vertical };

            box.AddChild(label);
            box.AddChild(ColorList);

            Tabs.AddChild(box);
            TabContainer.SetTabTitle(box, Loc.GetString("spray-painter-tabs-pipes"));

            foreach (var color in palette)
            {
                var locString = GetColorLocString(color.Key);
                var item = ColorList.AddItem(locString, _spriteSystem.Frame0(_colorEntryIconTexture));
                item.IconModulate = color.Value;
                item.Metadata = color.Key;

                ItemColorIndex.Add(color.Key, ColorList.IndexOf(item));
            }
        }

        var index = ItemColorIndex[selectedColorKey ?? _currentPalette.Keys.First()];
        ColorList[index].Selected = true;
        ColorList.OnItemSelected += OnColorPicked;
    }

    private void GenerateItems(ListData data, ListContainerButton button)
    {
        if (data is not SpriteListData spriteListData)
            return;

        var box = new BoxContainer() { Orientation = BoxContainer.LayoutOrientation.Horizontal };
        var protoView = new EntityPrototypeView();
        protoView.SetPrototype(spriteListData.Prototype?.ID);
        var label = new Label() { Text = spriteListData.Text };

        box.AddChild(protoView);
        box.AddChild(label);
        button.AddChild(box);
        button.AddStyleClass(ListContainer.StyleClassListContainerButton);

        if (spriteListData.SelectedIndex == button.Index)
            button.Pressed = true;
    }
}

record SpriteListData(string Category, string Text, EntityPrototype? Prototype, int SelectedIndex) : ListData;
